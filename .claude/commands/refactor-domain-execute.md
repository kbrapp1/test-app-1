# Domain Refactoring Execution Command

## 🎯 Command Purpose
Execute specific phases of domain refactoring based on markdown plans generated by `/refactor-domain`. Reads from persistent documentation to enable cross-session execution with validation checkpoints.

## 📋 Usage
```
/refactor-domain-execute <domain-name> <phase-identifier>
```

Examples:
- `/refactor-domain-execute chatbot-widget phase1`
- `/refactor-domain-execute chatbot-widget phase1-error-facade-removal`
- `/refactor-domain-execute dam phase2-architecture`
- `/refactor-domain-execute image-generator phase3-performance`

## 📖 Markdown Plan Integration

The command reads from persistent markdown documentation:
- **Plan Document**: `docs/refactor/{domain-name}-domain-refactoring-plan.md`
- **Execution Log**: `docs/refactor/{domain-name}-execution-log.md` (auto-created)
- **Progress Tracking**: Updates checkboxes in plan document
- **Cross-Session Support**: Resume work across multiple sessions

## 🔄 Execution Workflow

### **Pre-Execution Validation**

#### **1. Plan Document Validation**
```typescript
const planPath = `docs/refactor/${domainName}-domain-refactoring-plan.md`;
const planContent = await Read(planPath);

// Verify plan exists and is readable
if (!planContent) {
  throw new Error(`Plan not found: ${planPath}. Run /refactor-domain ${domainName} first.`);
}
```

#### **2. Phase Extraction**
```typescript
// Parse markdown to extract phase information
const phaseSection = extractPhaseSection(planContent, phaseIdentifier);
const phaseTasks = extractPhaseTasks(phaseSection);
const successCriteria = extractSuccessCriteria(phaseSection);
const readyToExecuteCommands = extractExecutionCommands(phaseSection);
```

#### **3. Current State Assessment**
- [ ] Plan document exists at `docs/refactor/{domain-name}-domain-refactoring-plan.md`
- [ ] Phase is defined with clear tasks and success criteria  
- [ ] Working in feature branch for refactoring
- [ ] CI/CD pipeline is green (run `pnpm run quality:check`)
- [ ] Current codebase state matches plan assumptions

#### **4. Security Pattern Verification**
```typescript
// Extract and verify critical security variables from plan
const securityRequirements = extractSecurityRequirements(planContent);
await validateSecurityPatternsPresent(securityRequirements);
```

#### **5. Prerequisites Check**
- [ ] Previous phases completed (if dependencies exist)
- [ ] Test suite is passing
- [ ] No uncommitted changes or merge conflicts
- [ ] Backup/snapshot created

### **Phase-Specific Execution Patterns**

#### **Phase 1: Foundation Fixes**
**Pattern: Conservative Changes First**
```
Execute in order:
1. Remove dead code and unused imports
2. Fix obvious DDD layer violations  
3. Consolidate duplicate logic patterns
4. Validate with unit tests
5. Run full type checking
```

#### **Phase 2: Structural Improvements**
**Pattern: File-by-File Refactoring**
```
Execute in order:
1. Refactor oversized files (>250 lines)
2. Extract domain services from bloated entities
3. Create missing value objects
4. Update imports and dependencies
5. Run integration tests
```

#### **Phase 3: Performance & Quality**
**Pattern: Optimization with Benchmarking**
```
Execute in order:
1. Baseline performance metrics
2. Optimize React Query patterns
3. Improve error handling
4. Add missing validation
5. Validate performance improvements
```

#### **Phase 4: Testing & Documentation**
**Pattern: Validation and Documentation**
```
Execute in order:
1. Add missing test coverage
2. Update architectural documentation
3. Run full regression test suite
4. Performance validation
5. Code quality metrics validation
```

## 📊 Execution Templates

### **File Refactoring Template**
For files exceeding 250 lines:

```typescript
// Current State Analysis
- File: {filename}
- Current Lines: {count}
- Target Lines: <250
- Primary Issues: {list from analysis}
- Preservation Requirements: {security/performance patterns}

// Refactoring Strategy
1. Remove dead code: {specific lines/methods}
2. Extract business logic: {specific methods to domain services}
3. Consolidate duplicates: {specific patterns}
4. Simplify complexity: {specific optimizations}

// Validation Checklist
- [ ] Functionality preserved
- [ ] Security variables maintained
- [ ] Performance patterns intact
- [ ] Tests passing
- [ ] Line count under 250
```

### **DDD Violation Fix Template**
For layer boundary violations:

```typescript
// Violation Details
- File: {filename}
- Issue: {specific violation description}
- Current Layer: {incorrect layer}
- Target Layer: {correct layer}
- Business Logic Affected: {description}

// Fix Strategy
1. Extract business logic to domain layer
2. Create proper application service coordination
3. Update infrastructure dependencies
4. Maintain presentation layer separation

// Validation Steps
- [ ] Business logic in domain layer
- [ ] Application layer coordinates only
- [ ] Infrastructure isolated
- [ ] Presentation layer clean
- [ ] All tests passing
```

### **Performance Optimization Template**
For performance improvements:

```typescript
// Performance Issue
- Component/Service: {name}
- Current Issue: {description}
- Performance Impact: {metrics}
- Optimization Target: {specific goals}

// Optimization Strategy
1. Baseline current performance
2. Implement optimization
3. Measure improvement
4. Validate no regressions

// Success Criteria
- [ ] Performance improvement measured
- [ ] No functional regressions
- [ ] Memory usage stable
- [ ] Bundle size impact acceptable
```

## 🧪 Testing Strategy

### **Incremental Testing Approach**
After each change:

1. **Unit Tests**: Run tests for modified files
2. **Integration Tests**: Run tests for affected domains
3. **Type Checking**: Validate TypeScript compliance
4. **Linting**: Ensure code quality standards
5. **Performance Tests**: Validate no regressions

### **Phase Completion Testing**
After each phase:

1. **Full Test Suite**: All tests must pass
2. **Build Verification**: Clean build required
3. **Security Validation**: Auth patterns verified
4. **Performance Benchmarks**: Metrics within targets
5. **Code Quality**: Quality gates must pass

## 🚨 Safety Mechanisms

### **Automatic Rollback Triggers**
Stop execution and consider rollback if:

- Any tests fail after changes
- TypeScript compilation errors
- Performance regression detected
- Security patterns broken
- Build process fails

### **Checkpoint System**
Create checkpoint after:

- Each file successfully refactored
- Each DDD violation fixed
- Each performance optimization
- Each phase completion

### **Validation Gates**
Before proceeding to next change:

- [ ] Current change compiles successfully
- [ ] Affected tests pass
- [ ] No security violations introduced
- [ ] Performance within acceptable range

## 📋 Execution Commands

### **Development Commands**
```bash
# Before starting phase
pnpm run quality:check
pnpm run test
pnpm run build

# During execution (after each change)
pnpm run typecheck
pnpm run lint
pnpm run test -- path/to/changed/files

# After phase completion
pnpm run test
pnpm run build
pnpm run quality:check
```

### **Git Workflow**
```bash
# Start phase
git checkout -b refactor/{domain}-{phase}
git commit -m "Start {phase}: {description}"

# After each significant change
git add .
git commit -m "refactor({domain}): {specific change description}"

# After phase completion
git commit -m "Complete {phase}: {summary of changes}"
```

## 📊 Progress Tracking

### **Markdown Plan Updates**
```typescript
// Update plan document with progress checkboxes
const updatedPlan = updateProgressCheckboxes(planContent, phaseIdentifier, completedTasks);

// Update specific patterns:
// - [ ] Task → - [x] Task (mark completed)
// - [ ] Analysis completed → - [x] Analysis completed
// - [ ] Implementation completed → - [x] Implementation completed  
// - [ ] Validation passed → - [x] Validation passed
// - [ ] Quality checks passed → - [x] Quality checks passed
// - [ ] Task Completed: All validation criteria met → - [x] Task Completed: All validation criteria met

await Write(planPath, updatedPlan);

// Create/update execution log
const logEntry = {
  timestamp: new Date().toISOString(),
  phase: phaseIdentifier,
  task: currentTask,
  status: 'completed',
  metrics: performanceMetrics,
  checkboxesUpdated: completedCheckboxes
};
await appendToExecutionLog(`docs/refactor/${domainName}-execution-log.md`, logEntry);
```

### **Phase Progress Template**
```markdown
## Execution Log: {domain-name}

### Phase: {phase-name}
- **Started**: {timestamp}
- **Progress**: {completed}/{total} items
- **Current Item**: {description}
- **Estimated Completion**: {time}
- **Issues Encountered**: {list}

#### Completed Tasks:
- [x] Task 1: {description} - {timestamp}
- [x] Task 2: {description} - {timestamp} 
- [ ] Task 3: {description} - In Progress
- [ ] Task 4: {description} - Pending
```

### **Cross-Session Recovery**
```typescript
// Read execution state from markdown files
const executionLog = await Read(`docs/refactor/${domainName}-execution-log.md`);
const lastCompletedTask = parseLastCompletedTask(executionLog);
const resumeFromTask = getNextPendingTask(planContent, lastCompletedTask);
```

### **Success Metrics Tracking**
```
Domain: {domain-name}
Phase: {phase-number}

Before:
- Files >250 lines: {count}
- DDD violations: {count}
- Test coverage: {percentage}
- Bundle size: {size}

After:
- Files >250 lines: {count}
- DDD violations: {count}  
- Test coverage: {percentage}
- Bundle size: {size}

Improvement: {summary}
```

## 🔄 Error Recovery

### **Common Issues & Solutions**

**TypeScript Errors:**
1. Analyze error context
2. Fix type definitions first
3. Update imports and exports
4. Validate changes incrementally

**Test Failures:**
1. Identify affected tests
2. Update test mocks if needed
3. Verify business logic preserved
4. Update test assertions if valid

**Performance Regressions:**
1. Revert last change
2. Analyze performance impact
3. Implement alternative approach
4. Re-measure performance

**DDD Violations:**
1. Re-read domain analysis
2. Verify correct layer placement
3. Check aggregate boundaries
4. Validate business rule preservation

## 📝 Completion Checklist

### **Phase Completion Requirements**
- [ ] All planned changes implemented
- [ ] Full test suite passing
- [ ] TypeScript compilation clean
- [ ] ESLint compliance achieved
- [ ] Performance benchmarks met
- [ ] Security patterns preserved
- [ ] Documentation updated
- [ ] Code review completed

### **Domain Completion Requirements**
- [ ] All phases successfully completed
- [ ] Success metrics achieved
- [ ] Regression testing passed
- [ ] Performance validation complete
- [ ] Security audit passed
- [ ] Team knowledge transfer complete
- [ ] Production deployment ready

## 🎯 Follow-up Commands

After execution:
- `/refactor-validate <phase-name>` - Validate phase completion
- `/refactor-status <domain-name>` - Check overall progress  
- `/refactor-metrics <domain-name>` - Review improvement metrics
- `/refactor-rollback <phase-name>` - Rollback if needed

## 💡 Usage Example

```bash
# 1. Generate domain analysis and markdown plan
/refactor-domain chatbot-widget
# → Creates docs/refactor/chatbot-widget-domain-refactoring-plan.md

# 2. Execute phases incrementally from markdown plan
/refactor-domain-execute chatbot-widget phase1
# → Reads plan, executes Phase 1 tasks, updates progress

/refactor-domain-execute chatbot-widget phase2
# → Continues from Phase 2, validates Phase 1 completion

# 3. Resume work in different session
/refactor-domain-execute chatbot-widget phase2-domain-events-infrastructure  
# → Reads execution state, resumes from specific task

# 4. Execute specific sub-tasks
/refactor-domain-execute chatbot-widget phase1-error-facade-removal
/refactor-domain-execute chatbot-widget phase1-vector-service-consolidation

# 5. Validate completion
/refactor-validate chatbot-widget
```

## 🔄 Cross-Session Workflow

### **Session 1: Start Foundation Phase**
```bash
/refactor-domain chatbot-widget                    # Generate plan
/refactor-domain-execute chatbot-widget phase1     # Start Phase 1
# Work interrupted...
```

### **Session 2: Resume Foundation Phase**  
```bash
/refactor-domain-execute chatbot-widget phase1     # Resume Phase 1
# → Reads execution log, continues from last checkpoint
```

### **Session 3: Move to Architecture Phase**
```bash
/refactor-domain-execute chatbot-widget phase2     # Start Phase 2
# → Validates Phase 1 completed, begins Phase 2
```

## 📖 Integration with Existing Commands

This command complements your existing refactoring workflow:

- **`/refactor-plan`** - Single file analysis and planning
- **`/refactor-domain`** - Full domain analysis (generates implementation plan)
- **`/refactor-domain-execute`** - Executes phases from domain analysis
- **`/refactor-execute`** - General refactoring execution (for single files)

Choose the right tool for the scope of your refactoring needs.